controller:
  type: daemonset

serviceAccount:
  create: true

rbac:
  create: true

service:
  enabled: true
  type: ClusterIP
  ports:
    - name: http
      port: 12345
      targetPort: 12345
    - name: otlp-grpc
      port: 4317
      targetPort: 4317
    - name: otlp-http
      port: 4318
      targetPort: 4318

alloy:
  stabilityLevel: "generally-available"

  extraPorts:
    - name: otlp-grpc
      port: 4317
      targetPort: 4317
      protocol: TCP
      appProtocol: h2c
    - name: otlp-http
      port: 4318
      targetPort: 4318
      protocol: TCP

  configMap:
    create: true
    content: |
      discovery.kubernetes "pods" {
        role = "pod"
      }

      prometheus.scrape "pods" {
        targets         = discovery.kubernetes.pods.targets
        forward_to      = [prometheus.remote_write.mimir.receiver]
        scrape_interval = "30s"
      }

      prometheus.remote_write "mimir" {
        endpoint {
          url = "http://mimir-k3s-gateway.scloud-observability.svc/api/v1/push"
        }
      }

      loki.source.kubernetes "pods" {
        targets    = discovery.kubernetes.pods.targets
        forward_to = [loki.write.loki.receiver]
      }

      loki.write "loki" {
        endpoint {
          url = "http://loki.scloud-observability.svc:3100/loki/api/v1/push"
        }
      }

      otelcol.receiver.otlp "otlp" {
        grpc { endpoint = "0.0.0.0:4317" }
        http { endpoint = "0.0.0.0:4318" }

        output {
          logs   = [otelcol.processor.attributes.loki_labels.input]
          traces = [otelcol.processor.memory_limiter.mem.input]
        }
      }

      otelcol.processor.memory_limiter "mem" {
        check_interval  = "1s"
        limit_mib       = 512
        spike_limit_mib = 256

        output {
          logs   = [otelcol.processor.batch.logs.input]
          traces = [otelcol.processor.batch.traces.input]
        }
      }

      otelcol.processor.attributes "loki_labels" {
        action {
          key            = "service_name"
          from_attribute = "service.name"
          action         = "upsert"
        }

        action {
          key            = "service_instance"
          from_attribute = "service.instance.id"
          action         = "upsert"
        }

        action {
          key    = "job"
          value  = "dns"
          action = "upsert"
        }

        action {
          key            = "service_name"
          from_attribute = "service.name"
          action         = "upsert"
        }

        output {
          logs = [otelcol.processor.memory_limiter.mem.input]
        }
      }

      otelcol.processor.batch "logs" {
        timeout         = "2s"
        send_batch_size = 512

        output {
          logs = [otelcol.exporter.loki.otlp.input]
        }
      }

      otelcol.processor.batch "traces" {
        timeout         = "5s"
        send_batch_size = 1024

        output {
          traces = [otelcol.exporter.otlp.tempo.input]
        }
      }

      otelcol.exporter.loki "otlp" {
        forward_to = [loki.write.loki.receiver]

        queue {
          enabled      = true
          num_consumers = 4
          queue_size    = 4096
        }

        retry_on_failure {
          enabled          = true
          initial_interval = "500ms"
          max_interval     = "10s"
          max_elapsed_time = "0s" # retry forever
        }
      }

      otelcol.exporter.otlp "tempo" {
        client {
          endpoint = "tempo.scloud-observability.svc:4317"
          tls { insecure = true }
        }
      }
